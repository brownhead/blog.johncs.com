<!DOCTYPE html>
<html>
<head>
    <title>John CS - Local Storage Today</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:300,400,600' rel='stylesheet' type='text/css'>

    <!-- inject:head:css -->
    <style>* {
  font-family: "Source Code Pro", serif;
  font-size: 12px;
  line-height: 16px;
  letter-spacing: 0;
}
body {
  background-color: #fdf6e3;
  color: #657b83;
  padding: 16px 2ch 160px 2ch;
}
@media (max-width: 46ch) {
  body {
    padding-bottom: 80px;
  }
}
a {
  text-decoration: none;
  color: #b58900;
}
a:hover {
  text-decoration: underline;
}
.single-column-content {
  max-width: 72ch;
  margin-left: auto;
  margin-right: auto;
}
.block-quote-markup {
  color: #859900;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}
tt {
  font-weight: 300;
}
.nav-bar {
  background-color: #eee8d5;
  border-left: 1ch solid #268bd2;
  border-right: 1ch solid #268bd2;
  margin-bottom: 16px;
  padding: 0 1ch;
}
.nav-bar ul {
  padding: 0;
  margin: 0;
  list-style: none;
  display: inline;
}
.nav-bar ul li {
  display: inline;
}
.nav-bar ul li:after {
  content: ", ";
}
.nav-bar ul li:last-child:after {
  content: "";
}
.nav-bar a {
  color: #268bd2;
}
img {
  background-color: #eee8d5;
  border-color: #eee8d5;
  border-style: solid;
  border-width: 16px 2ch;
  box-sizing: border-box;
  display: block;
  margin-bottom: 16px;
  margin-left: auto;
  margin-right: auto;
  max-width: 60ch;
  width: 100%;
}
img.small-image {
  max-width: 40ch;
}
img.tiny-image {
  max-width: 30ch;
}
@media (min-width: 80ch) {
  .floating-head {
    float: left;
    margin-right: 2ch;
  }
}
p,
ol,
ul {
  margin: 0 0 16px 0;
}
.post-body ol,
.post-body ul {
  list-style: none;
  padding: 0;
}
.post-body ol > li {
  counter-increment: item;
  padding-left: 4ch;
  position: relative;
}
.post-body ol > li:before {
  color: #859900;
  content: counter(item) ".";
  display: inline-block;
  left: 0;
  padding: 0 1ch;
  position: absolute;
}
.post-body ul > li {
  padding-left: 3ch;
  position: relative;
}
.post-body ul > li:before {
  color: #859900;
  content: "*";
  display: inline-block;
  left: 0;
  padding: 0 1ch;
  position: absolute;
}
.post-body .red-bold {
  color: #DC322F;
}
.post-body .rounded-40 {
  border-radius: 40px;
}
.post-body table.footnote td {
  padding: 0;
  margin: 0;
}
.post-body table.footnote td.label {
  padding-right: 1ch;
}
.post-body tt,
.post-body pre {
  font-weight: 300;
}
.post-body tt b,
.post-body pre b,
.post-body tt strong,
.post-body pre strong {
  font-weight: normal;
}
.post-body pre {
  padding: 0 0 0 4ch;
  white-space: pre-wrap;
}
.post-body h2,
.post-body h3,
.post-body h4,
.post-body h5,
.post-body h6 {
  font-weight: 600;
}
.post-body h2 *,
.post-body h3 *,
.post-body h4 *,
.post-body h5 *,
.post-body h6 * {
  font-weight: 600;
}
.post-body em,
.post-body i {
  font-style: normal;
  font-weight: 600;
}
.top-bar {
  background-color: #eee8d5;
  margin-bottom: 16px;
}
.top-bar .post-date {
  font-weight: 300;
  color: #6c71c4;
}
.top-bar a {
  color: #268bd2;
}
</style>
    <!-- endinject -->
</head>
<body class="single-column-content">
    <header class="top-bar">
        <a href="/">John CS</a> &gt; <a href="../blog-index.htm">Blog</a> &gt; Local Storage Today <span class="post-date">[12/22/2014]</span>
    </header>
    <div class="post-body">
        <div class="document">
<p>I'd like to write to <tt class="docutils literal">localStorage</tt> often. I'd also like to write to it synchronously in response to user interaction.</p>
<p>Past wisdom says this is a bad idea and will give me Angry Users Syndrome very quickly. Bad ideas are fun though, so let's see how much of a bad idea it is.</p>
<p>TL;DR: It's not a bad idea for (at least) the latest Firefox, WebKit, and Chromium browsers. <tt class="docutils literal">localStorage.setItem</tt> and <tt class="docutils literal">localStorage.getItem</tt> access fast in-memory data structures and updating the disk is done asynchronously in the background.</p>
<p>To get an idea of what we're looking at, let's take a quick dip into Firefox's source code (<a class="reference external" href="https://github.com/mozilla/gecko-dev">you can follow along on GitHub</a>). I'm starting from the top of the C++ implementation of <tt class="docutils literal">localstorage.setItem</tt> which is at <tt class="docutils literal"><span class="pre">DOMStorage::SetItem</span></tt> in <tt class="docutils literal">dom/storage/DOMStorage.cpp</tt>. There's nothing interesting in that function, but one layer deeper at <tt class="docutils literal"><span class="pre">DOMStorageCache::SetItem</span></tt> in <tt class="docutils literal">dom/storage/DOMStorageCache.cpp</tt> we get something interesting.</p>
<p>Below is the entirety of the function with my own comments. Sorry in advance for shoving a bunch of C++ at youâ€¦</p>
<pre class="code cpp literal-block">
<span class="c1">// Firefox loads all existing localStorage data from the disk the first
// it hits your site. If that operation hasn't finished yet, we get to
// twiddle our thumbs for a bit.
</span><span class="k">if</span> <span class="p">(</span><span class="n">Persist</span><span class="p">(</span><span class="n">aStorage</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">WaitForPreload</span><span class="p">(</span><span class="n">Telemetry</span><span>::</span><span class="n">LOCALDOMSTORAGE_SETVALUE_BLOCKING_MS</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">NS_FAILED</span><span class="p">(</span><span class="n">mLoadResult</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">mLoadResult</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// data is an in-memory hash table containing all of our localStorage
// data, so this is blazing fast.
</span><span class="n">Data</span><span>&amp;</span> <span class="n">data</span> <span>=</span> <span class="n">DataSet</span><span class="p">(</span><span class="n">aStorage</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span>!</span><span class="n">data</span><span class="p">.</span><span class="n">mKeys</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="n">aKey</span><span class="p">,</span> <span>&amp;</span><span class="n">aOld</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">SetDOMStringToNull</span><span class="p">(</span><span class="n">aOld</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Make sure the quota isn't going to be exeeded. Nothing terribly
// interesting here.
</span><span class="k">const</span> <span class="kt">int64_t</span> <span class="n">delta</span> <span>=</span> <span class="k">static_cast</span><span>&lt;</span><span class="kt">int64_t</span><span>&gt;</span><span class="p">(</span><span class="n">aValue</span><span class="p">.</span><span class="n">Length</span><span class="p">())</span> <span>-</span>
                      <span class="k">static_cast</span><span>&lt;</span><span class="kt">int64_t</span><span>&gt;</span><span class="p">(</span><span class="n">aOld</span><span class="p">.</span><span class="n">Length</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span>!</span><span class="n">ProcessUsageDelta</span><span class="p">(</span><span class="n">aStorage</span><span class="p">,</span> <span class="n">delta</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">NS_ERROR_DOM_QUOTA_REACHED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">aValue</span> <span>==</span> <span class="n">aOld</span> <span>&amp;&amp;</span> <span class="n">DOMStringIsNull</span><span class="p">(</span><span class="n">aValue</span><span class="p">)</span> <span>==</span> <span class="n">DOMStringIsNull</span><span class="p">(</span><span class="n">aOld</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">NS_SUCCESS_DOM_NO_OPERATION</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Update the in-memory hash table.
</span><span class="n">data</span><span class="p">.</span><span class="n">mKeys</span><span class="p">.</span><span class="n">Put</span><span class="p">(</span><span class="n">aKey</span><span class="p">,</span> <span class="n">aValue</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">Persist</span><span class="p">(</span><span class="n">aStorage</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span>!</span><span class="n">sDatabase</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NS_ERROR</span><span class="p">(</span><span>&quot;Writing to localStorage after the database has been shut down&quot;</span>
             <span>&quot;, data lose!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">NS_ERROR_NOT_INITIALIZED</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Asynchonously update the disk.
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">DOMStringIsNull</span><span class="p">(</span><span class="n">aOld</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">sDatabase</span><span>-&gt;</span><span class="n">AsyncAddItem</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">aKey</span><span class="p">,</span> <span class="n">aValue</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">sDatabase</span><span>-&gt;</span><span class="n">AsyncUpdateItem</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">aKey</span><span class="p">,</span> <span class="n">aValue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">NS_OK</span><span class="p">;</span>
</pre>
<p>The corresponding <tt class="docutils literal">localStorage.getItem</tt> implementation is even simpler and just accesses that hash table (it's in the same file if you want to take a look).</p>
<p>So to summarize: whenever we access <tt class="docutils literal">localStorage</tt> we're accessing a hash table and we're not going to block on the disk, unless we haven't finished the initial preload.</p>
<p>This is nice news and I like this, but there's quite a few browsers out there. Let's take a look at Chromium next (<a class="reference external" href="https://chromium.googlesource.com/chromium/src.git/+/master">follow along on Google Code</a>).</p>
<p><tt class="docutils literal"><span class="pre">WebStorageAreaImpl::setItem</span></tt> at <tt class="docutils literal">src/content/renderer/dom_storage/webstoragearea_impl.cc</tt> is the top of the C++ implementation, but again it doesn't have anything interesting. We need to dig down to <tt class="docutils literal"><span class="pre">DOMStorageCachedArea::SetItem</span></tt> in <tt class="docutils literal">src/content/renderer/dom_storage/dom_storage_cached_area.cc</tt> in order to see something cool (comments by me again):</p>
<pre class="code cpp literal-block">
<span class="c1">// A quick check to reject obviously overbudget items to avoid
// the priming the cache.
</span><span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span>+</span> <span class="n">value</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span>&gt;</span> <span class="n">kPerStorageAreaQuota</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// Similarily to Firefox, we load everything on disk into memory. It
// doesn't look like preloading is automatically triggered when users hit
// your site though, and must be manually initiated by accessing local
// storage.
</span><span class="n">PrimeIfNeeded</span><span class="p">(</span><span class="n">connection_id</span><span class="p">);</span>

<span class="c1">// map_ is (basically) a std::map object, which is going to be some data
// structure that lets you do this operation in O(log n) time.
</span><span class="n">base</span><span>::</span><span class="n">NullableString16</span> <span class="n">unused</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span>!</span><span class="n">map_</span><span>-&gt;</span><span class="n">SetItem</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span>&amp;</span><span class="n">unused</span><span class="p">))</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// Ignore mutations to 'key' until OnSetItemComplete.
</span><span class="n">ignore_key_mutations_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span>++</span><span class="p">;</span>

<span class="c1">// Asynchronously update the disk.
</span><span class="n">proxy_</span><span>-&gt;</span><span class="n">SetItem</span><span class="p">(</span>
    <span class="n">connection_id</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">page_url</span><span class="p">,</span>
    <span class="n">base</span><span>::</span><span class="n">Bind</span><span class="p">(</span><span>&amp;</span><span class="n">DOMStorageCachedArea</span><span>::</span><span class="n">OnSetItemComplete</span><span class="p">,</span>
               <span class="n">weak_factory_</span><span class="p">.</span><span class="n">GetWeakPtr</span><span class="p">(),</span> <span class="n">key</span><span class="p">));</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</pre>
<p>The corresponding <tt class="docutils literal">localStorage.getItem</tt> implementation just accesses the <tt class="docutils literal"><span class="pre">std::map</span></tt> object.</p>
<p>To summarize: Chromium behaves the same as Firefox except that it does not seem to preload the cache until you hit local storage for the first time.</p>
<p>WebKit seems like a good next target (<a class="reference external" href="https://github.com/WebKit/webkit">github</a>). <tt class="docutils literal"><span class="pre">Storage::setItem</span></tt> in <tt class="docutils literal">Source/WebCore/storage/Storage.cpp</tt> is the top of the implementation, and it does have something interesting for once. We can see that <a class="reference external" href="http://stackoverflow.com/a/14555361/3920202">private browsing mode kills localStorage</a>. Burying deeper down though we see a similar story at <tt class="docutils literal"><span class="pre">StorageAreaMap::setItem</span></tt> in <tt class="docutils literal">Source/WebKit2/WebProcess/Storage/StorageAreaMap.cpp</tt>.</p>
<p>I'm not going to paste the code here because it's basically the same as the above two. There's the wait on the preload, then an access to an in-memory data structure (a hash table this time), and then an asynchronous call to update the disk.</p>
<p>It would be a good idea to go back through the git history of the three repositories I've been looking at to see when they became super fast. I'd also like to do some testing to Internet Explorer to try and figure out if its implementation is also fast. I'll leave that to another post though.</p>
</div>

    </div>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-51104787-1', 'johncs.com');
        ga('send', 'pageview');
    </script>
</body>
</html>
