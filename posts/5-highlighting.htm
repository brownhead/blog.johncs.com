<!DOCTYPE html>
<html>
<head>
    <title>John CS - Intelligently Shortening Text</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">

    <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,800&subset=latin" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Inconsolata:400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.4.2/pure-min.css">
    <link rel="stylesheet" href="/styles.css">
    <link rel="stylesheet" href="/pygments.css">
</head>
<body id="post-page">
    <header id="top-header">
        <div id="post-title">
            <a id="site-title" href="/">John CS</a> &rarr; Intelligently Shortening Text
        </div>
        <div id="post-metadata" class="faded">
            Posted May 18, 2014
        </div>
    </header>
    <div id="post-body">
        <div class="document">
<p>Our search page at Khan Academy displays highlighting information to provide context for our results. Our full-text search engine gives us the highlighting text, but it doesn't provide a way to reliably control the length of the text. The end result can be undesirable...</p>
<img alt="A screenshot of Khan Academy's search results." class="align-center" src="/images/highlighting_before.png" style="width: 75%;" />
<p>Shrinking it in such a way that the result is &quot;good&quot; is difficult though. I was able to do it with a moderately straightforward algorithm to produce:</p>
<img alt="A screenshot of Khan Academy's search results with my algorithm applied." class="align-center" src="/images/highlighting_after.png" style="width: 75%;" />
<p>To get a grasp of the problem, take a look at the following text:</p>
<pre class="code html literal-block">
From this experiment we can make a key observation: The values in each
of the slices are equal to the the label on the slice, plus or minus
some <span class="nt">&lt;span</span> <span class="na">class=</span><span>&quot;highlighted&quot;</span><span class="nt">&gt;</span>multiple<span class="nt">&lt;/span&gt;</span> of C. This means the
difference between any two values in a slice is some
<span class="nt">&lt;span</span> <span class="na">class=</span><span>&quot;highlighted&quot;</span><span class="nt">&gt;</span>multiple<span class="nt">&lt;/span&gt;</span> of C.
</pre>
<p>If our target/optimal length is 125 characters, but we're willing to handle between 80 and 150 characters if necessary, what is the best result we could give? I'd say the second part of the first sentence, after the colon, because it's closest to the target length, it has a highlighted term in it, and it's an entire thought.</p>
<p>A way we can figure this out is by creating a list of &quot;stop points&quot; in the text. We want these stop points to be the beginning of a clause, but we can approximate this by declaring that stop points are the first alphanumeric character after a non-alphanumeric character and some whitespace. So in the string &quot;Our puppies are super smart -- seriously. They can fly planes!&quot;, the stop points would be the &quot;s&quot; in seriously, and the &quot;T&quot; in they. Additionally, we consider the beginning and end of a string to be stop points.</p>
<p>Each stop point represents a possible start/end point for our result. So we'll look at the string &quot;Our puppies are super smart --&quot;, and the string &quot;They can fly planes!&quot;, and the string &quot;Our puppies are super smart -- seriously.&quot;. Not all stop points are created equal however (as you may have noticed). We'd prefer to stop at the end of a sentence then in the middle of one for example. To represent this notion, we have the idea of &quot;preferred&quot; stop points. A preferred stop point is one with a capital letter (so the stop point at &quot;They&quot; is preferred, while the stop point at &quot;seriously&quot; is not).</p>
<p>We then look at all combinations of two stop points and look at the strings between them. These are our possible results. Every string that is outside of our min and max lengths is thrown out. Similarly, any string that does not include a highlighted term is thrown out. Finally, we take all of the strings that remain and rank them based on the preferred-ness of the stop points at each end of the string, and then on the proximity of the string's length to the target length. The string that is ranked highest wins.</p>
<p>There is also some handling for edge cases when the above algorithm can't work smoothly for whatever reason (ex: no combination in the target length or no highlighted terms in the source).</p>
</div>

    </div>
</body>
</html>
